# xml_handler
<!--
## Задание

Написать программу на Python, которая делает следующие действия:

### 1. 
Создает 50 zip-архивов, в каждом 100 xml файлов со случайными данными следующей структуры:

```xml
<root>
    <var name='id' value='<случайное уникальное строковое значение>'/>
    <var name='level' value='<случайное число от 1 до 100>'/>
    <objects>
        <object name='<случайное строковое значение>'/>
        <object name='<случайное строковое значение>'/>
        …
    </objects>
</root>
```

В тэге objects случайное число (от 1 до 10) вложенных тэгов object.


### 2. 
Обрабатывает директорию с полученными zip архивами, разбирает вложенные xml файлы и формирует 2 csv файла:

Первый: id, level - по одной строке на каждый xml файл

Второй: id, object_name - по отдельной строке для каждого тэга object (получится от 1 до 10 строк на каждый xml файл)

Очень желательно сделать так, чтобы задание 2 эффективно использовало ресурсы многоядерного процессора.

Также желательно чтобы программа работала быстро.

-->
## Решение

- Используем стандартную библиотеку для лучшей совместимости и простоты установки.
- Напишем код, работающий в Python версий 2 и 3.
- Модули для XML и CSV не используем, они избыточны для данной задачи.
- Случайные строки можно взять из UUID 4, но самодельная функция гибче.
- Ошибки в структуре XML файлов проверять не будем, потому что предполагается, что мы сами генерим данные, которые потом парсим.

## Решение можно было дополнить: 
- Обрабатывать ошибки, связанные с неправильной структурой XML файлов и битыми zip-архивами,
- Выделить больше параметров, передавать их в командной строке,
- Сделать файл конфигурации,
- Написать установщик,
- Прикрутить логгирование,
- Написать бенчмарки,
- Сделать побольше нормальных тестов,
- Написать документацию и сделать настройки для Sphinx.

## Установка и выполнение
Установка не требуется, запустить можно одним из вариантов:

    $ make run
    $ python -m xml_handler
    $ python xml_handler/xml_handler.py


## Тесты
Запускаем юнит-тесты:

    $ make test

Можно использовать tox, если он есть в системе.

    $ tox
